
struct GlobalData
{
	float4x4 proj;
	float4x4 view;
	float4x4 viewProj;
	float3 cameraPos;
	float padding0;			// 怕padding問題
	uint32_t directionalLightCount;
	uint32_t pointLightCount;
	uint32_t spotLightCount;
	uint32_t padding1;
};

forward Plus clustered
1. 所有Point Light
n. 根據cluster id找其light list


|- Scene Renderer
	每個Camera都有一個自己的Scene Renderer
	|- Size: Width, height
	|- 使用Forward Plus
	|- 2025/08/27 不使用PVP因為沒有要做bindless rendering
	1. Filter Renderable Mesh 
		Frustum Culling -> Filter給Mesh Renderer用
		ShadowMap可能需要自己額外實作Culling
	1. Render Depth only
		|- MeshDepthRenderer (使用Mesh但只Render depth，不care materials)
	2. Calculate the lighting tiles (compute shader)
	3. Render shadow maps
		Directional Light一定需要
		沒在light tiles裡的point light不用計算Shadow
	4. Render scene (Mesh Renderer)
	5. Post processing
	6. Canvas rendering (2D)
|- Graphics Pipeline
	就是ShaderProgram
|- Material
	|- 使用Component
	|- Graphics Pipeline: 使用什麼Shader
	|- Variables list
		{
			[Name]
			[Type]
			[Value]
		}
		Variable:
			|- Type: Buffer, Texture, float, int
	|- Raw Data
		GraphicsPipelineHandle graphicsPipeline;
		nvrhi::BindingSetHandle bindingSet;
|- Mesh 
	|- 使用Component
	|- AABB box
		用來Cull （Frustum Culling）
	|- Type:
		- Static  ：只有position, normal, texcoord
		- Animated：加上boneId, boneWeight
	|- SubMeshes List
		vertexOffset
		vertexCount
	|= Raw Data
		nvrhi::BufferHandle meshBuffer;

|- Skeleton
	|- 使用Component
	Animated Mesh 才需要
	有BoneId - BoneName的List
	|- Bone List
		[BoneID]
		[BoneName]
	|- Raw Data
		std::vector<BoneInfo> boneInfos;

|- Script Component
	|- namespace Name
	|- className
	